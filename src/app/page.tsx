"use client";

import React, { useState, useEffect, useMemo } from "react";
import { Toaster, toast } from "sonner";
import { FileExplorer } from "@/components/file-explorer";
import { UploadDialog } from "@/components/upload-dialog";
import { FilePreview } from "@/components/file-preview";
import { R2Object } from "@/lib/r2-types";
import { NewFolderDialog } from "@/components/new-folder-dialog";
import { Button } from "@/components/ui/button";
import { useConfig } from "@/contexts/config-context";
import { Loading } from "@/components/loading";
import { LayoutWithSidebar } from "@/components/layout-with-sidebar";
import { ImageCarousel } from "@/components/image-carousel";
import { ImageGrid } from "@/components/image-grid";

export default function Home() {
  const { isConfigValid, isLoading: isConfigLoading } = useConfig();
  
  const [files, setFiles] = useState<R2Object[]>([]);
  const [currentPrefix, setCurrentPrefix] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [showUploadDialog, setShowUploadDialog] = useState(false);
  const [showNewFolderDialog, setShowNewFolderDialog] = useState(false);
  const [selectedFile, setSelectedFile] = useState<R2Object | null>(null);
  const [signedUrl, setSignedUrl] = useState("");
  const [imageFiles, setImageFiles] = useState<R2Object[]>([]);
  const [imageUrls, setImageUrls] = useState<{ [key: string]: string }>({});
  const [carouselIndex, setCarouselIndex] = useState(0);
  const [showImageCarousel, setShowImageCarousel] = useState(false);
  const [viewMode, setViewMode] = useState<'list' | 'grid'>('list');
  const [isReadOnlyMode, setIsReadOnlyMode] = useState(false);

  // Âä†ËΩΩÊñá‰ª∂ÂàóË°®
  const loadFiles = async () => {
    try {
      setIsLoading(true);
      console.log(`Loading files from prefix: "${currentPrefix}"`);
      const response = await fetch(`/api/r2?action=listObjects&prefix=${encodeURIComponent(currentPrefix)}`);
      const data = await response.json();
      
      if (response.ok) {
        console.log("API response:", data);
        
        // Â∞ÜÊé•Êî∂Âà∞ÁöÑÊó•ÊúüÂ≠óÁ¨¶‰∏≤ËΩ¨Êç¢Âõû Date ÂØπË±°
        const filesWithDates = (data.objects || []).map(file => ({
          ...file,
          lastModified: new Date(file.lastModified)
        }));
        
        setFiles(filesWithDates);
        console.log("Processed files:", filesWithDates);
        
        // ËøáÊª§Âá∫ÂõæÁâáÊñá‰ª∂
        const imgExts = ["jpg", "jpeg", "png", "gif", "webp"];
        const imgFiles = filesWithDates.filter(file => {
          const ext = file.key.split('.').pop()?.toLowerCase() || '';
          return !file.isFolder && imgExts.includes(ext);
        });
        
        setImageFiles(imgFiles);
        console.log("Image files:", imgFiles);
        
        // Â¶ÇÊûúÊúâÂõæÁâáÊñá‰ª∂ÔºåÂä†ËΩΩÂÆÉ‰ª¨ÁöÑÈ¢ÑÁ≠æÂêçURL
        if (imgFiles.length > 0) {
          loadImageUrls();
        }
      } else {
        console.error("Error loading files:", data.error);
        toast.error("Failed to load files");
      }
    } catch (error) {
      console.error("Error loading files:", error);
      toast.error("Failed to load files");
    } finally {
      setIsLoading(false);
    }
  };

  // ÁõëÂê¨ÂâçÁºÄÂèòÂåñÈáçÊñ∞Âä†ËΩΩÊñá‰ª∂
  useEffect(() => {
    if (isConfigValid) {
      loadFiles();
    }
  }, [currentPrefix, isConfigValid]);

  // Â§ÑÁêÜÊñá‰ª∂ÁÇπÂáª
  const handleFileClick = async (file: R2Object) => {
    try {
      setSelectedFile(file);
      
      // Ê£ÄÊü•ÊòØÂê¶ÊòØÂõæÁâá
      const fileName = file.key.split("/").pop() || "";
      const ext = fileName.split(".").pop()?.toLowerCase() || "";
      const isImage = ["jpg", "jpeg", "png", "gif", "webp"].includes(ext);
      
      if (isImage) {
        // Â¶ÇÊûúÊòØÂõæÁâáÔºåÊ£ÄÊü•ÊòØÂê¶Â∑≤Êúâ URL
        if (!imageUrls[file.key]) {
          const response = await fetch(`/api/r2?action=getSignedUrl&key=${encodeURIComponent(file.key)}`);
          const data = await response.json();
          
          if (response.ok) {
            setImageUrls(prev => ({ ...prev, [file.key]: data.url }));
            setSignedUrl(data.url);
          } else {
            console.error("Error getting signed URL:", data.error);
            toast.error("Failed to generate download link");
            return;
          }
        } else {
          setSignedUrl(imageUrls[file.key]);
        }
        
        // ÊâæÂà∞ÂΩìÂâçÂõæÁâáÂú®ÂõæÁâáÊñá‰ª∂Êï∞ÁªÑ‰∏≠ÁöÑÁ¥¢Âºï
        const index = imageFiles.findIndex(img => img.key === file.key);
        if (index !== -1) {
          setCarouselIndex(index);
          setShowImageCarousel(true);
        }
      } else {
        // Â¶ÇÊûú‰∏çÊòØÂõæÁâáÔºåËé∑ÂèñÂ∏∏ËßÑÈìæÊé•
        const response = await fetch(`/api/r2?action=getSignedUrl&key=${encodeURIComponent(file.key)}`);
        const data = await response.json();
        
        if (response.ok) {
          setSignedUrl(data.url);
        } else {
          console.error("Error getting signed URL:", data.error);
          toast.error("Failed to generate download link");
        }
      }
    } catch (error) {
      console.error("Error getting signed URL:", error);
      toast.error("Failed to generate download link");
    }
  };

  // Â§ÑÁêÜÊñá‰ª∂‰∏ä‰º†
  const handleUpload = async (file: File, key: string) => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      
      const response = await fetch(`/api/r2?key=${encodeURIComponent(key)}&contentType=${encodeURIComponent(file.type)}`, {
        method: 'PUT',
        body: file
      });
      
      const data = await response.json();
      
      if (response.ok) {
        toast.success("Êñá‰ª∂‰∏ä‰º†ÊàêÂäü");
        loadFiles();
      } else {
        console.error("Error uploading file:", data);
        
        // Â§ÑÁêÜÊùÉÈôêÈîôËØØ
        if (response.status === 403 || data.errorCode === 'ACCESS_DENIED') {
          toast.error(data.error || "ÊùÉÈôêÈîôËØØÔºöÊ≤°Êúâ‰∏ä‰º†ÊùÉÈôê", {
            description: data.detail || "ÊÇ®ÁöÑ R2 ‰ª§Áâå‰∏çÂÖ∑Â§áÂÜôÂÖ•ÊùÉÈôêÔºåËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëòÊõ¥Êñ∞‰ª§ÁâåÊùÉÈôêÊàñ‰ΩøÁî®Âè™ËØªÊ®°ÂºèÊµèËßàÊñá‰ª∂„ÄÇ",
            duration: 6000,
            icon: "üîí"
          });
          
          // ËÆæÁΩÆUIÁä∂ÊÄÅ‰∏∫Âè™ËØªÊ®°Âºè
          setIsReadOnlyMode(true);
        } else {
          toast.error(data.error || "‰∏ä‰º†Â§±Ë¥•", {
            description: data.detail,
          });
        }
        throw new Error(data.error || "Upload failed");
      }
    } catch (error) {
      console.error("Error uploading file:", error);
      toast.error("‰∏ä‰º†Â§±Ë¥•", {
        description: error instanceof Error ? error.message : "Êú™Áü•ÈîôËØØ"
      });
      throw error;
    }
  };

  // Â§ÑÁêÜÊñá‰ª∂Âà†Èô§
  const handleDelete = async (file: R2Object) => {
    try {
      const response = await fetch('/api/r2?action=deleteObject', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ key: file.key }),
      });
      
      const data = await response.json();
      
      if (response.ok) {
        toast.success("Êñá‰ª∂Âà†Èô§ÊàêÂäü");
        setSelectedFile(null);
        loadFiles();
      } else {
        console.error("Error deleting file:", data);
        
        // Â§ÑÁêÜÊùÉÈôêÈîôËØØ
        if (response.status === 403 || data.errorCode === 'ACCESS_DENIED') {
          toast.error(data.error || "ÊùÉÈôêÈîôËØØÔºöÊ≤°ÊúâÂà†Èô§ÊùÉÈôê", {
            description: data.detail || "ÊÇ®ÁöÑ R2 ‰ª§Áâå‰∏çÂÖ∑Â§áÂÜôÂÖ•ÊùÉÈôêÔºåËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëòÊõ¥Êñ∞‰ª§ÁâåÊùÉÈôêÊàñ‰ΩøÁî®Âè™ËØªÊ®°ÂºèÊµèËßàÊñá‰ª∂„ÄÇ",
            duration: 6000,
            icon: "üîí"
          });
          
          // ËÆæÁΩÆUIÁä∂ÊÄÅ‰∏∫Âè™ËØªÊ®°Âºè
          setIsReadOnlyMode(true);
        } else {
          toast.error(data.error || "Âà†Èô§Â§±Ë¥•", {
            description: data.detail,
          });
        }
      }
    } catch (error) {
      console.error("Error deleting file:", error);
      toast.error("Âà†Èô§Â§±Ë¥•", {
        description: error instanceof Error ? error.message : "Êú™Áü•ÈîôËØØ"
      });
    }
  };

  // Â§ÑÁêÜÊâπÈáèÂà†Èô§
  const handleBatchDelete = async (files: R2Object[]) => {
    if (files.length === 0) return;
    
    if (!confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${files.length} ‰∏™Êñá‰ª∂ÂêóÔºü`)) {
      return;
    }

    try {
      const response = await fetch('/api/r2?action=deleteObjects', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ keys: files.map(file => file.key) }),
      });
      
      const data = await response.json();
      
      if (response.ok) {
        toast.success(`ÊàêÂäüÂà†Èô§ ${files.length} ‰∏™Êñá‰ª∂`);
        loadFiles();
      } else {
        console.error("Error deleting files:", data);
        
        // Â§ÑÁêÜÊùÉÈôêÈîôËØØ
        if (response.status === 403 || data.errorCode === 'ACCESS_DENIED') {
          toast.error(data.error || "ÊùÉÈôêÈîôËØØÔºöÊ≤°ÊúâÂà†Èô§ÊùÉÈôê", {
            description: data.detail || "ÊÇ®ÁöÑ R2 ‰ª§Áâå‰∏çÂÖ∑Â§áÂÜôÂÖ•ÊùÉÈôêÔºåËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëòÊõ¥Êñ∞‰ª§ÁâåÊùÉÈôêÊàñ‰ΩøÁî®Âè™ËØªÊ®°ÂºèÊµèËßàÊñá‰ª∂„ÄÇ",
            duration: 6000,
            icon: "üîí"
          });
          
          // ËÆæÁΩÆUIÁä∂ÊÄÅ‰∏∫Âè™ËØªÊ®°Âºè
          setIsReadOnlyMode(true);
        } else {
          toast.error(data.error || "ÊâπÈáèÂà†Èô§Â§±Ë¥•", {
            description: data.detail,
          });
        }
      }
    } catch (error) {
      console.error("Error deleting files:", error);
      toast.error("ÊâπÈáèÂà†Èô§Â§±Ë¥•", {
        description: error instanceof Error ? error.message : "Êú™Áü•ÈîôËØØ"
      });
    }
  };

  // Â§ÑÁêÜÂØºËà™
  const handleNavigate = (prefix: string) => {
    setCurrentPrefix(prefix);
  };

  // Â§ÑÁêÜÂàõÂª∫Êñá‰ª∂Â§π
  const handleCreateFolder = async (folderName: string) => {
    try {
      // Á°Æ‰øù currentPrefix Êú´Â∞æÊúâÊñúÊù†ÔºåËã•Â∑≤Â≠òÂú®Âàô‰∏çÊ∑ªÂä†
      const prefix = currentPrefix ? (currentPrefix.endsWith('/') ? currentPrefix : `${currentPrefix}/`) : '';
      const key = prefix + folderName;
      const response = await fetch('/api/r2?action=createFolder', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ key }),
      });
      
      const data = await response.json();
      
      if (response.ok) {
        toast.success("Êñá‰ª∂Â§πÂàõÂª∫ÊàêÂäü");
        loadFiles();
      } else {
        console.error("Error creating folder:", data);
        
        // Â§ÑÁêÜÊùÉÈôêÈîôËØØ
        if (response.status === 403 || data.errorCode === 'ACCESS_DENIED') {
          toast.error(data.error || "ÊùÉÈôêÈîôËØØÔºöÊ≤°ÊúâÂàõÂª∫Êñá‰ª∂Â§πÊùÉÈôê", {
            description: data.detail || "ÊÇ®ÁöÑ R2 ‰ª§Áâå‰∏çÂÖ∑Â§áÂÜôÂÖ•ÊùÉÈôêÔºåËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëòÊõ¥Êñ∞‰ª§ÁâåÊùÉÈôêÊàñ‰ΩøÁî®Âè™ËØªÊ®°ÂºèÊµèËßàÊñá‰ª∂„ÄÇ",
            duration: 6000,
            icon: "üîí"
          });
          
          // ËÆæÁΩÆUIÁä∂ÊÄÅ‰∏∫Âè™ËØªÊ®°Âºè
          setIsReadOnlyMode(true);
        } else {
          toast.error(data.error || "ÂàõÂª∫Êñá‰ª∂Â§πÂ§±Ë¥•", {
            description: data.detail,
          });
        }
      }
    } catch (error) {
      console.error("Error creating folder:", error);
      toast.error("ÂàõÂª∫Êñá‰ª∂Â§πÂ§±Ë¥•", {
        description: error instanceof Error ? error.message : "Êú™Áü•ÈîôËØØ"
      });
    }
  };

  // Âä†ËΩΩÊâÄÊúâÂõæÁâáÁöÑÈ¢ÑÁ≠æÂêç URL
  const loadImageUrls = async () => {
    if (imageFiles.length === 0) return;
    
    console.log("Loading image URLs for", imageFiles.length, "images");
    const newUrls: { [key: string]: string } = {};
    let hasError = false;
    
    for (const file of imageFiles) {
      if (imageUrls[file.key]) {
        console.log(`Skipping ${file.key}, URL already cached`);
        continue; // Ë∑≥ËøáÂ∑≤Êúâ URL ÁöÑÂõæÁâá
      }
      
      try {
        console.log(`Fetching signed URL for ${file.key}`);
        const response = await fetch(`/api/r2?action=getSignedUrl&key=${encodeURIComponent(file.key)}`);
        const data = await response.json();
        
        if (response.ok) {
          if (data.signedUrl) {
            console.log(`Got signed URL for ${file.key}`);
            newUrls[file.key] = data.signedUrl;
          } else {
            console.error(`Missing signedUrl in response for ${file.key}:`, data);
            hasError = true;
          }
        } else {
          console.error(`Error getting signed URL for ${file.key}:`, data.error);
          hasError = true;
        }
      } catch (error) {
        console.error(`Error getting signed URL for ${file.key}:`, error);
        hasError = true;
      }
    }
    
    if (Object.keys(newUrls).length > 0) {
      console.log(`Adding ${Object.keys(newUrls).length} new image URLs`);
      setImageUrls(prev => ({ ...prev, ...newUrls }));
    } else if (hasError) {
      toast.error("Failed to load some image previews");
    }
  };
  
  // ÂΩìÂõæÁâáÊñá‰ª∂ÂàóË°®ÂèòÂåñÊó∂ÔºåÂä†ËΩΩÈ¢ÑÁ≠æÂêç URL
  useEffect(() => {
    const imageFilesArray = Array.isArray(imageFiles) ? imageFiles : [];
    if (imageFilesArray.length > 0) {
      loadImageUrls();
    }
  }, [imageFiles]);

  // ËøêË°åËØäÊñ≠
  const runDiagnostics = async () => {
    try {
      const diagResponse = await fetch('/api/r2/diagnose');
      const diagData = await diagResponse.json();
      console.log("=== R2 DIAGNOSTICS ===");
      console.log(diagData);
      
      // Âú®È°µÈù¢‰∏äÊòæÁ§∫‰∏Ä‰∫õÈáçË¶Å‰ø°ÊÅØ
      if (diagData.connectionTest?.success) {
        toast.success("R2 ËøûÊé•ÊàêÂäüÔºÅÂèëÁé∞ " + (diagData.connectionTest.objects?.length || 0) + " ‰∏™ÂØπË±°");
      } else {
        toast.error("R2 ËøûÊé•Â§±Ë¥•: " + diagData.connectionTest?.message);
      }
    } catch (error) {
      console.error("ËØäÊñ≠ÈîôËØØ:", error);
      toast.error("ËøêË°åËØäÊñ≠Êó∂Âá∫Èîô");
    }
  };

  // ËÆ°ÁÆóÈ¢ÑËßàÊ®°Âºè‰∏ãÁöÑÂõæÁâáÊñá‰ª∂
  const visibleImageFiles = useMemo(() => {
    if (viewMode === 'list') return [];
    
    return imageFiles.filter(file => {
      // Âè™ÊòæÁ§∫ÂΩìÂâçÁõÆÂΩï‰∏ãÁöÑÂõæÁâáÔºåÈùûÂ≠êÁõÆÂΩï
      const relativePath = file.key.startsWith(currentPrefix) 
        ? file.key.slice(currentPrefix.length) 
        : file.key;
      
      return !relativePath.includes('/');
    });
  }, [viewMode, imageFiles, currentPrefix]);

  // ÂØπ‰∫éÂä†ËΩΩÂíåÈîôËØØÁä∂ÊÄÅÔºåÊòæÁ§∫ÂÖ®Â±èÂπïÊ∂àÊÅØ
  if (isConfigLoading) {
    return (
      <div className="flex min-h-screen flex-col items-center justify-center p-4">
        <Loading text="Ê≠£Âú®Âä†ËΩΩÈÖçÁΩÆ..." />
      </div>
    );
  }

  if (!isConfigValid) {
    return (
      <div className="flex min-h-screen flex-col items-center justify-center p-4">
        <div className="max-w-md w-full p-6 bg-white rounded-lg shadow-md dark:bg-gray-800 dark:text-white">
          <h1 className="text-2xl font-bold mb-4">ÈÖçÁΩÆ‰∏çÂÆåÊï¥</h1>
          <p className="mb-4">
            R2 ÈÖçÁΩÆ‰∏çÂÆåÊï¥„ÄÇËØ∑Âú®ËÆæÁΩÆÈ°µÈù¢ÂÆåÊàêÈÖçÁΩÆÔºö
          </p>
          <div className="flex justify-center mt-4">
            <Button asChild>
              <a href="/settings">ËΩ¨Âà∞ËÆæÁΩÆ</a>
            </Button>
          </div>
        </div>
      </div>
    );
  }
  
  // ÂØπ‰∫é‰∏ªÂÜÖÂÆπÔºå‰ΩøÁî®Â∏¶‰æßËæπÊ†èÁöÑÂ∏ÉÂ±Ä
  return (
    <LayoutWithSidebar>
      <div className="p-4 md:p-8">
        <Toaster position="top-right" />
        
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-3xl font-bold">Êñá‰ª∂ÊµèËßàÂô®</h1>
            <div className="flex items-center">
              <p className="text-muted-foreground">
                {currentPrefix ? `ÂΩìÂâçÁõÆÂΩï: ${currentPrefix}` : "Ê†πÁõÆÂΩï"}
              </p>
              {isReadOnlyMode && (
                <div className="ml-2 bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 px-2 py-1 rounded-md text-xs font-medium flex items-center">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-1">
                    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />
                    <path d="M8 11V9l8 8" />
                  </svg>
                  Âè™ËØªÊ®°Âºè
                </div>
              )}
            </div>
          </div>
        </div>
        
        <div className="mb-4 flex gap-2 justify-between">
          <div className="flex items-center gap-2">
            {/* ËßÜÂõæÂàáÊç¢ÊåâÈíÆ */}
            <Button
              variant={viewMode === 'list' ? "default" : "outline"}
              size="sm"
              onClick={() => setViewMode('list')}
              className="px-3"
            >
              <svg 
                width="16" 
                height="16" 
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="mr-2"
              >
                <line x1="8" y1="6" x2="21" y2="6" />
                <line x1="8" y1="12" x2="21" y2="12" />
                <line x1="8" y1="18" x2="21" y2="18" />
                <line x1="3" y1="6" x2="3.01" y2="6" />
                <line x1="3" y1="12" x2="3.01" y2="12" />
                <line x1="3" y1="18" x2="3.01" y2="18" />
              </svg>
              ÂàóË°®
            </Button>
            
            <Button
              variant={viewMode === 'grid' ? "default" : "outline"}
              size="sm"
              onClick={() => setViewMode('grid')}
              className="px-3"
            >
              <svg 
                width="16" 
                height="16" 
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="mr-2"
              >
                <rect x="3" y="3" width="7" height="7" />
                <rect x="14" y="3" width="7" height="7" />
                <rect x="14" y="14" width="7" height="7" />
                <rect x="3" y="14" width="7" height="7" />
              </svg>
              ÂõæÁâáÈõÜ
            </Button>
            
            {/* Êñá‰ª∂Êìç‰ΩúÊåâÈíÆ */}
            <Button 
              onClick={() => setShowNewFolderDialog(true)}
              disabled={isReadOnlyMode}
              title={isReadOnlyMode ? "Âè™ËØªÊ®°Âºè‰∏ã‰∏çÂèØÁî®" : "ÂàõÂª∫Êñ∞Êñá‰ª∂Â§π"}
              variant="outline"
              size="sm"
              className="px-3 ml-4"
            >
              <svg 
                width="16" 
                height="16" 
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="mr-2"
              >
                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />
                <line x1="12" y1="11" x2="12" y2="17" />
                <line x1="9" y1="14" x2="15" y2="14" />
              </svg>
              Êñ∞Âª∫Êñá‰ª∂Â§π
            </Button>
            
            <Button 
              onClick={() => setShowUploadDialog(true)}
              disabled={isReadOnlyMode}
              title={isReadOnlyMode ? "Âè™ËØªÊ®°Âºè‰∏ã‰∏çÂèØÁî®" : "‰∏ä‰º†Êñá‰ª∂"}
              variant="outline"
              size="sm"
              className="px-3"
            >
              <svg 
                width="16" 
                height="16" 
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="mr-2"
              >
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <polyline points="17 8 12 3 7 8" />
                <line x1="12" y1="3" x2="12" y2="15" />
              </svg>
              ‰∏ä‰º†
            </Button>
          </div>
          
          {/* ËØäÊñ≠ÊåâÈíÆ */}
          <Button
            variant="outline"
            size="sm"
            onClick={runDiagnostics}
            className="ml-auto"
            title="ËøêË°å R2 ËØäÊñ≠"
          >
            <svg 
              width="16" 
              height="16" 
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="mr-2"
            >
              <circle cx="12" cy="12" r="10" />
              <line x1="12" y1="16" x2="12" y2="12" />
              <line x1="12" y1="8" x2="12" y2="8" />
            </svg>
            ËØäÊñ≠
          </Button>
        </div>
        
        {viewMode === 'list' ? (
          <FileExplorer
            files={files}
            currentPrefix={currentPrefix}
            isLoading={isLoading}
            imageUrls={imageUrls}
            onFileClick={handleFileClick}
            onUploadClick={() => setShowUploadDialog(true)}
            onDeleteClick={handleBatchDelete}
            onNavigate={handleNavigate}
            onRefresh={loadFiles}
          />
        ) : (
          <ImageGrid
            files={visibleImageFiles}
            imageUrls={imageUrls}
            onImageClick={handleFileClick}
            onViewListMode={() => setViewMode('list')}
          />
        )}
        
        {showUploadDialog && (
          <UploadDialog
            currentPrefix={currentPrefix}
            onUpload={handleUpload}
            onClose={() => setShowUploadDialog(false)}
          />
        )}
        
        {showNewFolderDialog && (
          <NewFolderDialog
            currentPrefix={currentPrefix}
            onCreateFolder={handleCreateFolder}
            onClose={() => setShowNewFolderDialog(false)}
          />
        )}
        
        {selectedFile && signedUrl && !showImageCarousel && (
          <FilePreview
            file={selectedFile}
            signedUrl={signedUrl}
            onClose={() => {
              setSelectedFile(null);
              setSignedUrl("");
            }}
            onDelete={handleDelete}
            isReadOnly={isReadOnlyMode}
          />
        )}
        
        {showImageCarousel && imageFiles.length > 0 && (
          <ImageCarousel
            images={imageFiles.map(file => ({
              file,
              url: imageUrls[file.key] || ""
            })).filter(img => img.url)}
            initialIndex={carouselIndex}
            onClose={() => {
              setShowImageCarousel(false);
              setSelectedFile(null);
              setSignedUrl("");
            }}
          />
        )}
      </div>
    </LayoutWithSidebar>
  );
}
